import { serve } from "std/server.ts";
import { createClient } from "supabase/";
import { Buffer } from "std/io/buffer.ts";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL") ?? "";
const SUPABASE_ANON_KEY = Deno.env.get("SUPABASE_ANON_KEY") ?? "";
const STRIPE_SECRET_KEY = Deno.env.get("STRIPE_SECRET_KEY") ?? "";
const STRIPE_WEBHOOK_SECRET = Deno.env.get("STRIPE_WEBHOOK_SECRET") ?? "";

// Dummy Stripe library for demonstration. In a real scenario, you would use a proper Stripe client library.
const stripe = {
  webhooks: {
    constructEvent: (payload: string | Uint8Array, sig: string, secret: string) => {
      // This is a placeholder for Stripe webhook signature verification.
      // In a real application, you would use the official Stripe library to do this securely.
      // For now, we'll just check if the secret matches (for demonstration purposes only - DO NOT USE IN PRODUCTION)
      if (sig !== secret) {
        throw new Error("Webhook signature verification failed.");
      }
      return JSON.parse(new TextDecoder().decode(payload));
    },
  },
};

serve(async (req) => {
  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  try {
    const signature = req.headers.get("stripe-signature");
    if (!signature) {
      return new Response("No Stripe signature header", { status: 400 });
    }

    const bodyBuffer = await req.arrayBuffer();
    const rawBody = new Uint8Array(bodyBuffer);

    let event;
    try {
      event = stripe.webhooks.constructEvent(rawBody, STRIPE_WEBHOOK_SECRET, STRIPE_WEBHOOK_SECRET); // Using secret as signature for dummy verification
    } catch (err) {
      console.error(`⚠️  Webhook signature verification failed.`, err.message);
      return new Response(`Webhook Error: ${err.message}`, { status: 400 });
    }

    const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      global: { headers: { Authorization: req.headers.get("Authorization")! } },
      auth: { persistSession: false },
    });

    switch (event.type) {
      case "checkout.session.completed":
        const checkoutSession = event.data.object;
        // Fulfill the purchase... e.g., create a license for the user
        console.log("Checkout session completed:", checkoutSession);
        // You would typically get user_id from checkoutSession.client_reference_id or metadata
        // And product, plan, features from line items or metadata

        // Example: Inserting a placeholder license (replace with actual logic)
        const { data: user, error: userError } = await supabaseClient
            .from("users")
            .select("id")
            .eq("email", checkoutSession.customer_details.email)
            .single();
        
        let userId = user?.id;

        if (userError || !user) {
            // If user doesn't exist, create one. In a real app, you might link to existing auth.
            const { data: newUserData, error: newUserError } = await supabaseClient.from("users").insert({ email: checkoutSession.customer_details.email }).select("id").single();
            if (newUserError) {
                console.error("Error creating new user:", newUserError);
                return new Response(JSON.stringify({ error: newUserError.message }), { status: 500, headers: { "Content-Type": "application/json" } });
            }
            userId = newUserData?.id;
        }

        // Here, you would call your `issue_license` Edge Function or directly interact with the database
        // For simplicity, we'll directly insert a license here. In production, consider calling the Edge Function.
        const license_id = crypto.randomUUID();
        const issued_at = Math.floor(Date.now() / 1000);
        const expires_at = issued_at + 365 * 24 * 60 * 60; // 1 year validity
        const nonce = crypto.randomUUID();
        const product = "UploadBridge Pro"; // Example
        const plan = "premium"; // Example
        const features = { cloud_sync: true, updates: true }; // Example
        const device_fingerprint = ""; // This should be handled by the user's desktop app registration

        const { error: licenseInsertError } = await supabaseClient.from("licenses").insert({
            id: license_id,
            user_id: userId,
            product,
            plan,
            features,
            device_fingerprint,
            issued_at: new Date(issued_at * 1000).toISOString(),
            expires_at: new Date(expires_at * 1000).toISOString(),
            nonce,
            signature: "", // Signature would typically be generated by issue_license Edge Function
        });

        if (licenseInsertError) {
            console.error("Error inserting license for checkout session:", licenseInsertError);
            return new Response(JSON.stringify({ error: licenseInsertError.message }), { status: 500, headers: { "Content-Type": "application/json" } });
        }

        break;
      case "customer.subscription.deleted":
        const subscriptionDeleted = event.data.object;
        // Handle subscription cancelled, revoke license
        console.log("Subscription deleted:", subscriptionDeleted);
        // You would typically find the associated license and mark it as inactive or revoke it
        // For example, retrieve license by customer_id or subscription_id and update its status
        const { error: revokeError } = await supabaseClient.from("licenses").update({ is_active: false }).eq("user_id", subscriptionDeleted.customer);

        if (revokeError) {
            console.error("Error revoking license on subscription deletion:", revokeError);
        }
        break;
      // ... handle other event types
      default:
        console.log(`Unhandled event type ${event.type}`);
    }

    return new Response(JSON.stringify({ received: true }), { status: 200, headers: { "Content-Type": "application/json" } });
  } catch (error) {
    console.error("Edge Function error:", error);
    return new Response(JSON.stringify({ error: error.message }), { status: 500, headers: { "Content-Type": "application/json" } });
  }
});
