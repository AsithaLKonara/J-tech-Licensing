# End-to-End License Issuance and Verification Flow\n\nThis document outlines the complete flow for how licenses are issued, how devices are registered, and how licenses are verified across the desktop application, Supabase Edge Functions, and the Supabase Postgres database.\n\n## 1. License Issuance Flow\n\n**Actors:** Next.js Dashboard (Admin/User), Stripe Webhook (via checkout.session.completed), `issue_license` Edge Function, Supabase Postgres.\n\n1.  **User Initiates Purchase (Dashboard/Stripe):**\n    *   A user either purchases a license through the Next.js dashboard (e.g., admin generates one) or completes a purchase via Stripe Checkout.\n2.  **Stripe Webhook (if applicable):**\n    *   If purchased via Stripe, Stripe sends a `checkout.session.completed` webhook event to the `stripe_webhook` Edge Function.\n    *   `stripe_webhook` Edge Function verifies the Stripe signature for authenticity.\n    *   `stripe_webhook` extracts relevant purchase details (user email, product, plan, features, validity period).\n    *   If the user doesn't exist in the `users` table, a new user record is created.\n    *   `stripe_webhook` then calls (internally or directly inserts) the logic to issue a license.\n3.  **`issue_license` Edge Function (or direct call):**\n    *   Receives parameters: `user_id`, `product`, `plan`, `features`, `expires_in_days`, `device_fingerprint` (initially optional, can be set on first device registration).\n    *   Generates a unique `license_id` and `nonce`.\n    *   Calculates `issued_at` and `expires_at` timestamps.\n    *   Constructs the license payload (JSON object) including all relevant license details.\n    *   Retrieves the **private signing key** from Supabase secrets.\n    *   Cryptographically signs the license payload using the private key (ECDSA/ES256), creating a JWT.\n    *   Stores the full JWT (or its signature and payload details) into the `licenses` table in Supabase Postgres.\n    *   Returns the signed license JWT to the calling application (e.g., Next.js dashboard for download, or desktop app directly if initiated there).\n\n## 2. Device Registration Flow\n\n**Actors:** Desktop Application, `register_device` Edge Function, Supabase Postgres.\n\n1.  **Desktop App Generates Fingerprint:**\n    *   The desktop application generates a unique and stable device fingerprint (e.g., hash of hardware identifiers).\n    *   The fingerprint should be consistent across reboots and re installations on the same device.\n2.  **Desktop App Calls `register_device`:**\n    *   The desktop application sends the `device_fingerprint` and optionally a `device_name` to the `register_device` Edge Function.\n    *   This call should be authenticated with a Supabase Auth JWT (e.g., from a user logged into the dashboard or a pre-shared API key for device-only registration).\n3.  **`register_device` Edge Function:**\n    *   Authenticates the request (ensuring a valid user is associated or an allowed device registration method).\n    *   Validates the `device_fingerprint`.\n    *   Checks if the `device_fingerprint` already exists.\n        *   If it exists and belongs to the *same user*, it returns a success indicating the device is already registered.\n        *   If it exists and belongs to a *different user*, it rejects the registration to prevent fingerprint spoofing/collision.\n    *   Inserts a new record into the `devices` table with `user_id`, `fingerprint`, `name`, and `last_seen` timestamp.\n    *   Returns success status.\n\n## 3. License Verification Flow (Online - Heartbeat/Validation)\n\n**Actors:** Desktop Application, `validate_license` Edge Function, Supabase Postgres.\n\n1.  **Desktop App Initiates Online Check:**\n    *   The desktop application periodically (e.g., once every 24 hours, or on app launch) sends its currently held `license_jwt` and its `device_fingerprint` to the `validate_license` Edge Function.\n    *   This call does not strictly require a logged-in user, but can use an authenticated session for enhanced audit logging.\n2.  **`validate_license` Edge Function:**\n    *   Retrieves the **public signing key** from Supabase secrets.\n    *   Verifies the `license_jwt` using the public key (cryptographic signature check).\n        *   If signature is invalid, rejects the license.\n    *   Parses the `license_jwt` payload.\n    *   Checks `expires_at` timestamp in the payload against the current time.\n        *   If expired, rejects the license.\n    *   Compares the `device_fingerprint` from the payload with the `device_fingerprint` provided by the desktop app.\n        *   If they don\'t match, rejects the license (anti-sharing mechanism).\n    *   Queries the `revoked_licenses` table in Supabase Postgres using `license_id` from the payload.\n        *   If an entry is found, rejects the license (online revocation check).\n    *   Queries the `licenses` table to ensure the `is_active` status is true.\n        *   If `is_active` is false, rejects the license.\n    *   If all checks pass, updates the `last_seen` timestamp for the device in the `devices` table.\n    *   Logs an audit event in the `audit_logs` table (including user\_id if available, license\_id, device\_fingerprint, IP address).\n    *   Returns a success status and optionally the license payload to the desktop application.\n3.  **Desktop App Action:**\n    *   If validation succeeds, the application continues to operate normally.\n    *   If validation fails, the application can enter a grace period, display a warning, or disable features.\n\n## 4. License Verification Flow (Offline - Initial/Fallback)\n\n**Actors:** Desktop Application (Public Key Only).\n\n1.  **Desktop App Receives/Stores License:**\n    *   The desktop application receives the `license_jwt` (e.g., downloaded from the dashboard, or provided during initial setup).\n    *   It stores this `license_jwt` securely locally.\n2.  **Desktop App Performs Offline Checks:**\n    *   Retrieves the **public signing key** embedded within its own code.\n    *   Verifies the `license_jwt` using the embedded public key (cryptographic signature check).\n        *   If signature is invalid, rejects the license.\n    *   Parses the `license_jwt` payload.\n    *   Checks `expires_at` timestamp in the payload against the current system time.\n        *   If expired, rejects the license.\n    *   Generates its own `device_fingerprint` and compares it to the `device_fingerprint` stored in the license payload.\n        *   If they don\'t match, rejects the license.\n    *   **Crucially, offline verification CANNOT check the real-time revocation list or `is_active` status.** This is why online validation is critical.\n3.  **Desktop App Action:**\n    *   If offline verification passes, the application can start with full functionality, but should still attempt online validation if possible.\n    *   If offline validation fails, the application should not allow access to licensed features.\n\n## 5. License Revocation Flow\n\n**Actors:** Next.js Dashboard (Admin/User), `revoke_license` Edge Function, Supabase Postgres.\n\n1.  **User/Admin Initiates Revocation (Dashboard/Stripe Webhook):**\n    *   An admin can manually revoke a license through the Next.js dashboard.\n    *   A user might cancel a subscription, triggering a Stripe `customer.subscription.deleted` webhook event to the `stripe_webhook` Edge Function.\n2.  **`stripe_webhook` Edge Function (if applicable):**\n    *   Verifies the Stripe signature.\n    *   Identifies the license(s) associated with the cancelled subscription/customer.\n    *   Calls (internally or directly updates) the logic to revoke the license.\n3.  **`revoke_license` Edge Function (or direct call):**\n    *   Receives `license_id` and optional `reason`.\n    *   Authenticates the request (ensuring the user has permission to revoke the license or it's an internal system call).\n    *   Inserts a new record into the `revoked_licenses` table with `license_id`, `reason`, and `revoked_by`.\n        *   A unique constraint on `license_id` in `revoked_licenses` prevents duplicate revocations.\n    *   Updates the `is_active` flag to `false` in the `licenses` table for the corresponding `license_id`.\n    *   Returns success status.\n4.  **Desktop Application Response (via Online Validation):**\n    *   The next time the desktop application performs an online `validate_license` check, it will discover the license has been revoked and act accordingly (e.g., disable features, warn user).\n